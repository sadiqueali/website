<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sadique Ali</title>
    <link>http://sadique.io/categories/java/index.xml</link>
    <description>Recent content on Sadique Ali</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="http://sadique.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A very basic introduction to deploying a Java application using Kubernetes</title>
      <link>http://sadique.io/blog/2016/11/04/a-very-basic-introduction-to-deploying-a-java-application-using-kubernetes/</link>
      <pubDate>Fri, 04 Nov 2016 22:34:53 -0700</pubDate>
      
      <guid>http://sadique.io/blog/2016/11/04/a-very-basic-introduction-to-deploying-a-java-application-using-kubernetes/</guid>
      <description>

&lt;p&gt;I have been playing around with Kubernetes and Docker lately. To borrow the description of Kubernetes from their website,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the first things I did was to try and see what it would take to go from an application to deploying it. I started with a simple Java application and had to set up the development environment. These are my notes from this process. This assumes that you have docker installed on your development environment.&lt;/p&gt;

&lt;h2 id=&#34;install-minikube&#34;&gt;Install minikube&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube&#34;&gt;Minikube&lt;/a&gt; is a tool that makes it easy to run Kubernetes for local development. To run minikube, you need to have a virtualizer installed - in my case I already had VirtualBox installed. Instructions for installing minikube is available &lt;a href=&#34;https://github.com/kubernetes/minikube/releases&#34;&gt;here&lt;/a&gt;. In my case, this is what I did:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.12.2/minikube-darwin-amd64
&amp;gt; chmod +x minikube
&amp;gt; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-kubectl&#34;&gt;Install kubectl&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/kubectl-overview/&#34;&gt;Kubectl&lt;/a&gt; is a command line application that executes commands against Kubernets clusters. Instructions for installing kubectl are available &lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/minikube/#install-kubectl&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.3.0/bin/darwin/amd64/kubectl
&amp;gt; chmod +x kubectl
&amp;gt; sudo mv kubectl /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;set-up-a-docker-repository&#34;&gt;Set up a Docker repository&lt;/h2&gt;

&lt;p&gt;Kubernetes pulls container images from publicly available registries. But because we are building an application that we will not be publishing to public docker registries, we need to create a local registry. There is a great write up on how to set up a local docker registry at &lt;a href=&#34;http://thenewstack.io/tutorial-configuring-ultimate-development-environment-kubernetes/&#34;&gt;Newstack&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;start-minikube-with-the-registry&#34;&gt;Start minikube with the registry&lt;/h2&gt;

&lt;p&gt;Now that we have a local docker registry, we can go ahead and tell minikube to consume images from this registry. However, if you have started a minikube cluster previously, the registry override will not be available to it unless it is deleted.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker-machine ip registry
192.168.99.100
&amp;gt; minikube stop
&amp;gt; minikube delete
&amp;gt; minikube start --vm-driver=&amp;quot;virtualbox&amp;quot; --insecure-registry=192.168.99.100:80
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-a-container-image-for-the-application&#34;&gt;Create a container image for the application&lt;/h2&gt;

&lt;p&gt;The application in this case is a simple Spring Boot application that has exactly one controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class HelloController {
  @RequestMapping(&amp;quot;/hello&amp;quot;)
  public Map hello() {
    return singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to create a docker container from this application, we will use the &lt;a href=&#34;https://github.com/spotify/docker-maven-plugin&#34;&gt;Maven Docker Plugin&lt;/a&gt;. We will need to set a prefix for our docker image. This can be done with this maven property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;docker.image.prefix&amp;gt;sadiqueio&amp;lt;/docker.image.prefix&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Th plugin expects a &lt;code&gt;Dockerfile&lt;/code&gt; to be present in the &lt;code&gt;src/main/docker&lt;/code&gt; directory. Our &lt;code&gt;Dockerfile&lt;/code&gt; will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM frolvlad/alpine-oraclejdk8:slim
ADD hello-world-0.0.1-SNAPSHOT.jar app.jar
RUN sh -c &#39;touch /app.jar&#39;
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this in place, we can generate a docker image. We need to ensure that we are looking at the dev docker host.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eval $(docker-machine env dev)
&amp;gt; mvn package docker:build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tag-and-push-the-image-to-local-registry&#34;&gt;Tag and push the image to local registry&lt;/h2&gt;

&lt;p&gt;The generated image &lt;code&gt;sadiqueio/hello-world&lt;/code&gt; need to be published to the local registry we created.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker tag sadiqueio/hello-world 192.168.99.100:80/hello-world
&amp;gt; docker push 192.168.99.100:80/hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;define-and-create-a-service&#34;&gt;Define and create a service&lt;/h2&gt;

&lt;p&gt;We will define a Kubernetes service object for this application &lt;code&gt;hello-world-service.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: hello-world
  labels:
    app: hello-world
    tier: backend
spec:
  type: NodePort
  ports:
    # the port that this service should serve on
  - port: 8080
  selector:
    app: hello-world
    tier: backend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The service can be created using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; kubectl create -f hello-world-service.yaml
You have exposed your service on an external port on all nodes in your
cluster.  If you want to expose this service to the external internet, you may
need to set up firewall rules for the service port(s) (tcp:30194) to serve traffic.

See http://releases.k8s.io/release-1.3/docs/user-guide/services-firewalls.md for more details.
service &amp;quot;hello-world&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make a note of the port assigned to this service. We will use this port later to access our application.&lt;/p&gt;

&lt;h2 id=&#34;define-and-create-a-deployment&#34;&gt;Define and create a deployment&lt;/h2&gt;

&lt;p&gt;The next step is to define and create a deployment for our application. This is where we specify the image we previously created and published to the registry.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: hello-world
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: hello-world
        tier: backend
    spec:
      containers:
      - name: hello-world
        image: 192.168.99.100:80/hello-world
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; kubectl create -f hello-world-deployment.yaml
deployment &amp;quot;hello-world&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ensure-that-the-deployment-is-successful&#34;&gt;Ensure that the deployment is successful&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; kubectl get services
NAME          CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
hello-world   10.0.0.252   &amp;lt;none&amp;gt;        8080/TCP   4m
&amp;gt; kubectl get deployments
NAME          DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
hello-world   1         1         1            1           4m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;access-the-service&#34;&gt;Access the service&lt;/h2&gt;

&lt;p&gt;We already know the port assigned to our service. Because we specified &lt;code&gt;type: NodePort&lt;/code&gt;, the IP address we need to use is that of the Kubernetes cluster. This IP address can be found using the minikube command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; minikube ip
192.168.99.102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have both pieces of information, we can test that our application is up.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; curl  -s http://192.168.99.102:30194/hello | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is it. We have deployed our hello world application using Kubernetes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handling Deserialization errors in Spring Redis Sessions</title>
      <link>http://sadique.io/blog/2016/11/02/handling-deserialization-errors-in-spring-redis-sessions/</link>
      <pubDate>Wed, 02 Nov 2016 13:10:33 -0700</pubDate>
      
      <guid>http://sadique.io/blog/2016/11/02/handling-deserialization-errors-in-spring-redis-sessions/</guid>
      <description>&lt;p&gt;One of the challenges of using storing spring sessions in Redis is that the objects that gets stored as part of a session often undergoes changes as the application evolves and these changes cause de-serialization exceptions to be thrown after a deployment when a session created before the deployment is presented to the application. This blog post discusses a method to work around this issue.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-issue&#34;&gt;The issue&lt;/h2&gt;

&lt;p&gt;Consider an application that uses a custom authentication service to validate credentials presented by a client. To achieve this, we will wire up a custom authentication provider which creates an object &lt;code&gt;Customer&lt;/code&gt; as the authenticated user in session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer extends User {
  public Customer(String name) {
    super(name, &amp;quot;&amp;quot;, Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;USER&amp;quot;)));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Things work great, but after a while the team decides to store the logged in user&amp;rsquo;s email address in the session. To achieve this, we change the &lt;code&gt;Customer&lt;/code&gt; type to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer extends User {
  private String email;

  public Customer(String name, String email) {
    super(name, &amp;quot;&amp;quot;, Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;USER&amp;quot;)));
    this.email = email;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this code is deployed and a user tries to access a protected resource by presenting a session created before the deployment, an exception is thrown.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.InvalidClassException: in.sdqali.spring.vo.Customer; local class incompatible: stream classdesc serialVersionUID = 5161850915957547690, local class serialVersionUID = 1045726772100761661
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This happens because the serialized object in the session and the current structure of the session differ.&lt;/p&gt;

&lt;h2 id=&#34;solutions&#34;&gt;Solutions&lt;/h2&gt;

&lt;p&gt;This issue was raised on the Spring Session issue tracker &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; and there were a lot of work-arounds discussed. Of the work arounds, wrapping the session repository offers the least disruption to the end user.
This approach ensures that every time a de-serialization error is thrown while trying to read an object from the session, that object is deleted, preventing subsequent errors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SafeDeserializationRepository&amp;lt;S extends ExpiringSession&amp;gt; implements SessionRepository&amp;lt;S&amp;gt; {
  private final SessionRepository&amp;lt;S&amp;gt; delegate;
  private final RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate;

  private static final String BOUNDED_HASH_KEY_PREFIX = &amp;quot;spring:session:sessions:&amp;quot;;
  private static final Logger logger = getLogger(SafeDeserializationRepository.class);

  public SafeDeserializationRepository(SessionRepository&amp;lt;S&amp;gt; delegate,
                                       RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate) {
    this.delegate = delegate;
    this.redisTemplate = redisTemplate;
  }

  @Override
  public S createSession() {
    return delegate.createSession();
  }

  @Override
  public void save(S session) {
    delegate.save(session);
  }

  @Override
  public S getSession(String id) {
    try {
      return delegate.getSession(id);
    } catch(SerializationException e) {
      logger.info(&amp;quot;Deleting non-deserializable session with key {}&amp;quot;, id);
      redisTemplate.delete(BOUNDED_HASH_KEY_PREFIX + id);
      return null;
    }
  }

  @Override
  public void delete(String id) {
    delegate.delete(id);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, it is not easy to wire up this repository in the configuration. Since Spring Redis Session is auto configured, the only way to override beans for Redis Session is to extend &lt;code&gt;RedisHttpSessionConfiguration&lt;/code&gt; and specify beans. Ideally, we want to override the method &lt;code&gt;RedisHttpSessionConfiguration#sessionRepository&lt;/code&gt;. This would mean that &lt;code&gt;SafeDeserializationRepository&lt;/code&gt; inherits from &lt;code&gt;RedisOperationsSessionRepository&lt;/code&gt;. That does not sound too complicated till you realize that &lt;code&gt;RedisOperationsSessionRepository#getSession(java.lang.String)&lt;/code&gt; returns &lt;code&gt;RedisSession&lt;/code&gt; which is a final class declared inside &lt;code&gt;RedisOperationsSessionRepository&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On closer look, the repository is hooked in to &lt;code&gt;SessionRepositoryFilter&lt;/code&gt; and it is indeed possible to override the &lt;code&gt;SpringHttpSessionConfiguration#springSessionRepositoryFilter&lt;/code&gt; method to create a new filter that takes our &lt;code&gt;SafeDeserializationRepository&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RedisSessionConfig extends RedisHttpSessionConfiguration {
  @Autowired
  RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate;

  @Bean
  @Override
  public &amp;lt;S extends ExpiringSession&amp;gt; SessionRepositoryFilter&amp;lt;? extends ExpiringSession&amp;gt; springSessionRepositoryFilter(SessionRepository&amp;lt;S&amp;gt; sessionRepository) {
    return super.springSessionRepositoryFilter(new SafeDeserializationRepository&amp;lt;&amp;gt;(sessionRepository, redisTemplate));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://github.com/spring-projects/spring-session/issues/280&#34;&gt;SerializationFailedException after re-deploying with changed session object #280&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>